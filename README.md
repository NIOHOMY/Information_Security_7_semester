## Лабораторная № 1

Необходимо программно реализовать алгоритм двойной перестановки.

Для этого открытый текст записывается в матрицу по определенному ключу k1, определяющему порядок записи открытого текста в строки матрицы при шифровании. 

Шифртекст образуется при считывании из этой матрицы по ключу k2, определяющему, в каком порядке записывается информация из столбцов матрицы. 

Программа должна осуществлять шифрование и расшифровку по приведенному выше алгоритму, вывод на экран незашифрованного, зашифрованного и расшифрованного сообщения.

Открытый текст: ШИФРОВАНИЕ_ПЕРЕСТАНОВКОЙ.

### [смотреть решение](https://github.com/NIOHOMY/Information_Security_7_semester/blob/lab6/src/main/kotlin/lab1/Main.kt)

## Лабораторная № 2

В ходе лабораторной работы необходимо реализовать алгоритм замены Вижинера с помощью какого-либо языка программирования. 

Программа должна осуществлять шифрование и расшифровку по приведенному выше алгоритму, вывод на экран незашифрованного, зашифрованного и расшифрованного сообщения.

### [смотреть решение](https://github.com/NIOHOMY/Information_Security_7_semester/blob/lab6/src/main/kotlin/lab2/Main.kt)

## Лабораторная № 3

В ходе лабораторной работы необходимо программно реализовать алгоритм RSA (алгоритм асимметричного шифрования с открытым ключом) с помощью какого-либо языка программирования (без подключения встроенных модулей шифрования используемого языка программирования). 

Программа должна вычислять числа n, φ(n), e, d, осуществлять шифрование и расшифровку по приведенному выше алгоритму, вывод на экран открытого сообщения, зашифрованного и расшифрованного сообщения, открытый и закрытый ключи, а также число φ(n). 

<details>
<summary> Алгоритм RSA </summary>

Указанный алгоритм используется во многих стандартах, среди которых SSL, S-HHTP, S-MIME, S/WAN, STT и PCT.

Основными математическими результатами, положенными в основу этого алгоритма являются: малая теорема Ферма и функция Эйлера.

Открытый текст шифруется блоками, каждый из которых содержит двоичное значение, меньшее некоторого заданного числа n. Это значит, что  длина блока должна быть меньше или равна log2(n). На практике длина блока выбирается равной 2k битам, где  2k < n < 2k+1 

Шифрование и дешифрование для блока открытого текста M и блока шифрованного текста С можно представить в виде:
- C = Memod n 
- M = Cdmod n = Medmod n = M mod n. 

Отправитель и получатель должны знать значение n. Отправитель знает значение e и только получатель знает значение d. 

Таким образом, открытым ключом является {e, n}, а личным закрытым ключом {d, n}. 

При этом должны быть выполнены следующие требования: 
- Должны существовать такие значения e, d и n, при которых выполняется Medmod n = M mod n для всех значений M < n. 
- Должны относительно легко вычисляться Me и Cd для всех значений   M < n. 
- Должно быть практически невозможно определить d по имеющимся e и n. 

Схема шифрования выглядит следующим образом: 

1. Выбираются два простых числа p и q . (Например, p=7 и q=17).
2. Вычисляется n = p٠q. (n = 119).
3. Определяется φ(n)=(p – 1)(q – 1). (φ(n)=96).
4. Выбор числа e, взаимно простого с φ(n), причем e < φ(n). (e = 5).
5. Вычисляется d = e-1 mod φ(n)
- (Определяется такое d, что (d٠e) mod 96 = 1 и e < 96. Соответствующим значением будет d = 77, так как 77٠5 = 385 = 4٠96+1). 
6. Открытым ключом является {e, n}. ({e, n}={5, 119}).
7. Закрытым ключом является {d, n}. ({d, n}={77, 119}).
8. Шифрование C = Memod n 
9. Дешифрование M = Cdmod n

**Рассмотрим небольшой пример, иллюстрирующий применение алгоритма RSA.**

Зашифруем сообщение "САВ". Для простоты будем использовать маленькие простые числа (на практике применяются гораздо большие). 

Выберем p = 3 и q =11. Определим n = 3٠11= 33. Найдем (p −1)(q −1) = 20. 

Следовательно, в качестве e, взаимно простого с φ(n)=20, возьмем например, e = 7. Выберем число d. В качестве такого числа может быть взято любое число, для которого удовлетворяется соотношение 
- (d٠e)mod20 = (d٠7)mod20 =1, например d = 3. 

Представим шифруемое сообщение как последовательность целых чисел с помощью отображения: A →1, B → 2,C → 3. Тогда сообщение принимает вид (3,1,2). 

Зашифруем сообщение с помощью ключа {7,33}: 

- (37)mod33 = 2187mod33 = 9, 
- (17)mod33 = 1mod33 = 1,
- (27)mod33 = 128mod33 = 29. 

Расшифруем полученное зашифрованное сообщение (9,1,29) на основе закрытого ключа {3,33}:

- (93)mod33 = 729mod33 = 3, 
- (13)mod33 = 1mod33 = 1, 
- (293)mod33 = 24389mod33 = 2. 

Итак, в реальных системах алгоритм RSA реализуется следующим образом: каждый пользователь выбирает два больших простых числа p и q, и в соответствии с описанным выше алгоритмом выбирает два простых числа e и d. 

Как результат умножения первых двух чисел (p,q) устанавливается n, {e, n} образует открытый ключ, а {d, n} - закрытый (хотя можно взять и наоборот). 

Открытый ключ публикуется и доступен каждому, кто желает послать владельцу ключа сообщение, которое зашифровывается указанным алгоритмом. После шифрования, сообщение невозможно раскрыть с помощью открытого ключа. 

Владелец же закрытого ключа без труда может расшифровать принятое сообщение. 

</details>

### [смотреть решение](https://github.com/NIOHOMY/Information_Security_7_semester/blob/lab6/src/main/kotlin/lab3/Main.kt)

## Лабораторная № 6

Реализация дискреционной модели политики безопасности

### [смотреть решение](https://github.com/NIOHOMY/Information_Security_7_semester/blob/lab6/src/main/kotlin/lab6/Main.kt)
